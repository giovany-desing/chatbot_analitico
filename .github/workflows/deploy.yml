name: CD - Deploy to AWS

on:
  workflow_dispatch:  # Solo deploy manual por ahora

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Create deployment package
      run: |
        tar -czf app_deploy.tar.gz \
          --exclude='*.pyc' \
          --exclude='__pycache__' \
          --exclude='.git' \
          --exclude='venv' \
          --exclude='terraform' \
          --exclude='backups' \
          --exclude='.env' \
          app/ scripts/ data/ migrations/ requirements.txt Dockerfile docker-compose.aws.yml

    - name: Upload to EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ec2-user
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      run: |
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts

        # Upload deployment package
        scp -i ~/.ssh/deploy_key app_deploy.tar.gz $EC2_USER@$EC2_HOST:/tmp/

    - name: Deploy on EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ec2-user
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      run: |
        ssh -i ~/.ssh/deploy_key $EC2_USER@$EC2_HOST << 'ENDSSH'
          set -e
          cd /opt/chatbot
          
          # Obtener valores de Parameter Store
          DB_HOST=$(aws ssm get-parameter --name "/chatbot-analitico/prod/db/host" --region us-east-1 --query 'Parameter.Value' --output text)
          DB_NAME=$(aws ssm get-parameter --name "/chatbot-analitico/prod/db/name" --region us-east-1 --query 'Parameter.Value' --output text)
          DB_USER=$(aws ssm get-parameter --name "/chatbot-analitico/prod/db/username" --region us-east-1 --with-decryption --query 'Parameter.Value' --output text)
          DB_PASS=$(aws ssm get-parameter --name "/chatbot-analitico/prod/db/password" --region us-east-1 --with-decryption --query 'Parameter.Value' --output text)
          GROQ_KEY=$(aws ssm get-parameter --name "/chatbot-analitico/prod/api/groq_key" --region us-east-1 --with-decryption --query 'Parameter.Value' --output text)
          MODAL_KEY=$(aws ssm get-parameter --name "/chatbot-analitico/prod/api/modal_key" --region us-east-1 --with-decryption --query 'Parameter.Value' --output text)
          FINETUNED_ENDPOINT=$(aws ssm get-parameter --name "/chatbot-analitico/prod/api/finetuned_model_endpoint" --region us-east-1 --query 'Parameter.Value' --output text 2>/dev/null || echo "")
          S3_TRAINING=$(aws ssm get-parameter --name "/chatbot-analitico/prod/s3/training_bucket" --region us-east-1 --query 'Parameter.Value' --output text)
          S3_BACKUPS=$(aws ssm get-parameter --name "/chatbot-analitico/prod/s3/backups_bucket" --region us-east-1 --query 'Parameter.Value' --output text)
          MYSQL_URI=$(aws ssm get-parameter --name "/chatbot-analitico/prod/external/mysql_uri" --region us-east-1 --with-decryption --query 'Parameter.Value' --output text 2>/dev/null || echo "")
          
          # Parsear MySQL URI
          if [ ! -z "$MYSQL_URI" ] && [ "$MYSQL_URI" != "NOT_CONFIGURED" ] && [ "$MYSQL_URI" != "PLACEHOLDER" ]; then
            MYSQL_USER=$(echo "$MYSQL_URI" | sed -n 's|.*://\([^:]*\):.*|\1|p')
            MYSQL_PASSWORD=$(echo "$MYSQL_URI" | sed -n 's|.*://[^:]*:\([^@]*\)@.*|\1|p')
            MYSQL_HOST=$(echo "$MYSQL_URI" | sed -n 's|.*@\([^:]*\):.*|\1|p')
            MYSQL_PORT=$(echo "$MYSQL_URI" | sed -n 's|.*:\([0-9]*\)/.*|\1|p')
            MYSQL_DATABASE=$(echo "$MYSQL_URI" | sed -n 's|.*/\([^?]*\).*|\1|p')
          else
            MYSQL_USER=""
            MYSQL_PASSWORD=""
            MYSQL_HOST=""
            MYSQL_PORT="3306"
            MYSQL_DATABASE=""
          fi
          
          # Crear .env
          cat > .env << EOF
          POSTGRES_HOST=${DB_HOST}
          POSTGRES_PORT=5432
          POSTGRES_DB=${DB_NAME}
          POSTGRES_USER=${DB_USER}
          POSTGRES_PASSWORD=${DB_PASS}

          MYSQL_HOST=${MYSQL_HOST}
          MYSQL_PORT=${MYSQL_PORT:-3306}
          MYSQL_USER=${MYSQL_USER}
          MYSQL_PASSWORD=${MYSQL_PASSWORD}
          MYSQL_DATABASE=${MYSQL_DATABASE}

          GROQ_API_KEY=${GROQ_KEY}
          MODAL_API_KEY=${MODAL_KEY}
          FINETUNED_MODEL_ENDPOINT=${FINETUNED_ENDPOINT}

          S3_TRAINING_BUCKET=${S3_TRAINING}
          S3_BACKUPS_BUCKET=${S3_BACKUPS}

          ENVIRONMENT=production
          AWS_DEFAULT_REGION=us-east-1
          EOF

          # Backup current version
          docker-compose -f docker-compose.aws.yml down || true

          # Extract new version
          sudo rm -rf app/ scripts/ data/ migrations/ requirements.txt Dockerfile docker-compose.aws.yml
          sudo tar -xzf /tmp/app_deploy.tar.gz -C .
          sudo chown -R ec2-user:ec2-user /opt/chatbot
          rm /tmp/app_deploy.tar.gz

          # Rebuild and restart
          docker-compose -f docker-compose.aws.yml up -d --build

          # Wait for health check
          echo "Esperando a que la aplicación inicie..."
          sleep 20

          # Verify deployment
          if curl -f http://localhost:8000/health; then
            echo "✅ Deployment successful"
          else
            echo "❌ Health check failed"
            exit 1
          fi
        ENDSSH

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "✅ Deployment completed successfully"
        else
          echo "❌ Deployment failed"
        fi

